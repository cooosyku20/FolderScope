# Go コーディング標準ガイド

このリポジトリのGoコードを生成、レビュー、または修正する際には、以下のコーディング標準とベストプラクティスに従ってください。以下のガイドラインには、優先度と適用コンテキストが含まれています：

**優先度**:
- [必須]: 基本的なコード品質とセキュリティのために不可欠
- [重要]: コードの保守性、読みやすさ、安全性を大きく向上
- [推奨]: より良いコードとプロセスのためのベストプラクティス

**適用コンテキスト**:
- [全般]: すべてのGoコード
- [スクリプト]: 単一のプログラムやコマンドラインツール
- [ライブラリ]: 再利用可能なパッケージ/ライブラリ
- [アプリ]: 大規模アプリケーション/サービス

**カテゴリ**:
- [コード]: コードの書き方に関する項目
- [設計]: コード設計・構造に関する項目
- [ツール]: 利用するツールや自動化に関する項目
- [セキュリティ]: セキュリティに関する項目
- [プロセス]: 開発プロセスに関する項目

## 1. Goの慣用的コードスタイル [コード]

- [必須] Go標準フォーマットに従う [全般]
    - `gofmt` / `go fmt` を使用する。エディタ連携やCIでのチェックを推奨。
- [必須] Goに適した命名規則を遵守する [全般]
    - パッケージ名: 小文字、アンダースコアなし (`httputil`)。そのパッケージの内容を表す名前にする。
    - 公開識別子 (Exported): 大文字始まり (`PublicFunction`, `UserService`)。
    - 非公開識別子 (Unexported): 小文字始まり (`privateFunction`, `userService`)。
    - インターフェース名: `Reader`, `Writer` など (`er` 接尾辞が多い)。単一メソッドの場合はメソッド名+er (`Reader` for `Read()`)。
    - 略語: 一貫性を持たせる (`UserID` または `userId` のどちらかに統一、`HTTPClient` など)。一般的には全て大文字 (`ID`, `URL`, `HTTP`)。
- [必須] 効果的にエラーを処理する [全般]
- [重要] コンテキスト（context）を適切に使用する [全般]
- [重要] ゼロ値を活用する [全般]
- [重要] 効率的なコードを書く [全般]
- [推奨] コードを明確かつ簡潔に保つ [全般]

エラー処理の良い例:
```go
// 良い例: %w でラップしコンテキスト追加 (Go 1.13+)
if err != nil {
    return fmt.Errorf("failed to process request: %w", err)
}
// 良い例: 早期リターン
if err := validate(input); err != nil {
    return fmt.Errorf("validation failed: %w", err)
}
```

コードを明確かつ簡潔に保つ例:
```go
// 良い例: 早期リターン
func checkPermissions(user *User, resource *Resource) error {
    if user == nil { return errors.New("user is nil") }
    if !user.IsActive { return errors.New("user is inactive") }
    if !user.CanAccess(resource) { return errors.New("permission denied") }
    // ... 許可された場合の処理 ...
    return nil
}
```

## 2. コード構造と設計 [設計]

- [必須] 単一責任の原則を適用する [全般]
    - 関数、メソッド、型（構造体、インターフェース）は、それぞれ単一の明確な責任を持つように設計する。
    - 巨大な関数や型は分割を検討する。
    ```go
    // 良い例: 責任分離
    type UserRepo struct { db *sql.DB } // DB操作
    func (r *UserRepo) GetByID(id string) (*User, error) { /* ... */ }
    type AuthService struct { repo UserRepo } // 認証ロジック
    func (s *AuthService) Authenticate(u, p string) (bool, error) { /* ... */ }
    ```
- [必須] インターフェースを受け取り、構造体を返す [全般]
    - 関数やメソッドの引数では、具体的な型ではなくインターフェース型を使用することで、柔軟性とテスト容易性を高める。
    - コンストラクタ関数 (`NewXxx`) は、具体的な構造体のポインタを返すのが一般的。
    ```go
    // 良い例
    type Cache interface { Get(key string) (any, bool); Set(key string, val any) }
    func NewHandler(cache Cache) *Handler { /* ... */ } // インターフェースを受け取る

    type Handler struct{ cache Cache }
    func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) { /* ... */ }
    ```
- [重要] コンテキスト（context）を適切に使用する [全般]
    - I/O処理、外部API呼び出し、リクエストスコープの処理を行う関数では、第一引数として `context.Context` を受け取る。
    - タイムアウトやキャンセル伝播のために適切に利用する。
    ```go
    func ProcessRequest(ctx context.Context, req *Request) (*Response, error) {
        // タイムアウト付きサブコンテキスト作成
        timeoutCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel() // cancel() の呼び出しを忘れない

        data, err := fetchData(timeoutCtx, req.ID) // サブ処理にコンテキストを渡す
        // ...
    }
    ```
- [重要] 関心の分離を実践する [ライブラリ] [アプリ]
    - アプリケーションの異なる側面（例: UI/API、ビジネスロジック、データアクセス、外部サービス連携）を明確に分離する。
    - レイヤードアーキテクチャ、ヘキサゴナルアーキテクチャなどの設計パターンを検討する。
- [重要] 小さく集中したパッケージを設計する [ライブラリ] [アプリ]
    - パッケージはその名前が示す責任範囲に集中する。
    - 循環依存を避けるようにパッケージ構造を設計する。
    - `util`, `common`, `helper` のような汎用パッケージの作成は慎重に行い、肥大化させない。

## 3. エラー処理とログ記録 [コード]

- [必須] エラーを値として扱い、適切に伝播させる [全般]
    - エラーは無視せず、チェック (`if err != nil`) する。
    - 呼び出し元にエラーを返す場合は、`fmt.Errorf` と `%w` を使ってコンテキストを追加し、元のエラーをラップする (Go 1.13+)。
    ```go
    func readFile(path string) ([]byte, error) {
        data, err := os.ReadFile(path)
        if err != nil {
            return nil, fmt.Errorf("readFile %s: %w", path, err) // %w でラップ
        }
        return data, nil
    }
    ```
- [重要] エラー種類の区別にはカスタムエラー型またはエラー変数を使用する [全般]
    - 特定のエラー状態を区別する必要がある場合、パッケージレベルのエラー変数（センチネルエラー）やカスタムエラー型を定義する。
    - エラーの判定には `errors.Is` (値の比較) や `errors.As` (型の比較と値の取得) を使用する。
    ```go
    // センチネルエラー
    var ErrResourceNotFound = errors.New("resource not found")
    // カスタムエラー型
    type NetworkError struct { Host string; Err error }
    func (e *NetworkError) Error() string { /* ... */ }
    func (e *NetworkError) Unwrap() error { return e.Err } // errors.Is/As でラップされたエラーを辿れるように

    // 呼び出し側
    err := action()
    if errors.Is(err, ErrResourceNotFound) { /* ... */ }
    var netErr *NetworkError
    if errors.As(err, &netErr) { /* ... netErr.Host ... */ }
    ```
- [重要] エラー処理を簡潔に保ち、エラーを一度だけチェックする [全般]
    - `if err != nil { return err }` のパターンを基本とし、早期リターンを活用する。
    - 正常系のコードのネストを深くしない。
- [重要] 構造化ロギングを使用して一貫性のあるログ出力を行う [アプリ]
    - ログメッセージだけでなく、関連する情報（リクエストID, ユーザーID, エラー情報など）をキーと値のペアで記録する (`JSON`, `logfmt` など)。
    - `log/slog` (Go 1.21+), `logrus`, `zap` などのライブラリ利用を検討する。
    ```go
    // slog 例 (Go 1.21+)
    slog.Error("Failed to process order", "order_id", orderID, "error", err)
    ```
- [重要] パニックは控えめに使用し、必ず回復させる (リカバリ可能な範囲で) [全般]
    - パニックは、プログラムが回復不能な状態に陥った場合（例: 初期化時の致命的なエラー）や、プログラマのバグ（例: nilポインタ参照、インデックス範囲外アクセス）を示すために限定的に使用する。
    - 公開APIやリクエストハンドラ、Goroutineのトップレベルなど、予期せぬパニックが発生しうる箇所では `defer` と `recover` を使用してパニックを捕捉し、ログ記録や適切なエラー処理を行う。
    ```go
    // defer + recover 例
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Recovered from panic: %v\n%s", r, debug.Stack())
            // エラー応答やリソース解放などの処理
        }
    }()
    ```

## 4. 並行処理 [コード]

- [必須] Goroutineを適切に管理し、リークを防止する [全般]
    - `sync.WaitGroup` を使用して、起動したGoroutineの完了を待つ。
    - ループ内でGoroutineを起動する場合、ループ変数をGoroutineに正しく渡す（引数として渡すか、内部で再束縛する）。
    ```go
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        i := i // ループ変数キャプチャ
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println("Worker", i)
        }()
    }
    wg.Wait()
    ```
- [必須] コンテキストを使用してGoroutineのライフサイクルを制御する [全般]
    - タイムアウト、デッドライン、キャンセルシグナルをGoroutine間で伝播させるために `context.Context` を使用する。
    - I/Oやブロッキング処理を行う関数には `ctx` を渡し、処理の途中で `ctx.Done()` をチェックして早期終了できるようにする。
    - `context.WithCancel`, `context.WithTimeout`, `context.WithDeadline` で生成したコンテキストの `cancel` 関数を `defer` で呼び出す。
    ```go
    func longOperation(ctx context.Context) error {
        select {
        case <-time.After(10 * time.Second): // 時間のかかる処理
            fmt.Println("Operation finished")
            return nil
        case <-ctx.Done(): // キャンセル/タイムアウトを検知
            fmt.Println("Operation cancelled:", ctx.Err())
            return ctx.Err()
        }
    }
    ```
- [重要] 適切な同期プリミティブを選択する [全般]
    - `sync/atomic`: 低レベルなアトミック操作（カウンタ、フラグなど）に。
    - `sync.Mutex`: 共有リソースへの排他的アクセス制御に。クリティカルセクションは短く保つ。
    - `sync.RWMutex`: 読み取りが書き込みより圧倒的に多い場合の共有リソースアクセス制御に。
    - `sync.Once`: 一度だけの初期化処理に。
    - チャネル (`chan`): Goroutine間の通信、同期、処理の受け渡しに。
- [重要] チャネルの使用パターンを理解する [全般]
    - バッファなしチャネルは送受信の同期に使われる。
    - バッファ付きチャネルは限定的な非同期性や流量制御に使われる。
    - 送信側がチャネルを `close` し、受信側は `for range` や `v, ok := <-ch` でクローズを検知する。
    - `select` ステートメントで複数のチャネル操作を非ブロッキングまたはタイムアウト付きで待機する。
- [重要] エラー処理を含む並列処理を実装する [全般]
    - 複数のGoroutineからのエラーを集約する方法を確立する（エラーチャネル、`sync.Mutex` で保護されたスライスなど）。
    - 1つのGoroutineでエラーが発生した場合に、他の関連するGoroutineをキャンセルする仕組みを検討する（`context` や `errgroup` パッケージ）。
    ```go
    // errgroup 例
    g, ctx := errgroup.WithContext(context.Background())
    for _, arg := range args {
        arg := arg
        g.Go(func() error {
            // ctx を使って処理
            return process(ctx, arg) // エラーを返すとctxがキャンセル
        })
    }
    if err := g.Wait(); err != nil { /* 最初のエラーを処理 */ }
    ```

## 5. データと状態管理 [コード]

- [必須] イミュータブルなデータパターンを優先する [全般]
    - 可能な限り、状態を変更するメソッドではなく、変更された新しい値を持つコピーを返すメソッドを設計する。特に並行処理で有利。
    ```go
    type Config struct { values map[string]string }
    func (c Config) WithValue(key, value string) Config {
        newMap := make(map[string]string, len(c.values)+1)
        for k, v := range c.values { newMap[k] = v }
        newMap[key] = value
        return Config{values: newMap} // 新しいインスタンスを返す
    }
    ```
- [重要] 値レシーバとポインタレシーバを適切に使い分ける [全般]
    - メソッドがレシーバの状態を変更する必要がある場合 -> ポインタレシーバ (`*T`)。
    - 状態を変更しない、またはコピーコストが無視できるほど小さい場合 -> 値レシーバ (`T`)。
    - 大きな構造体の場合は、コピーコストを避けるためにポインタレシーバ (`*T`) を検討する。
    - nil レシーバで安全に動作する必要がある場合 -> ポインタレシーバ (`*T`) でnilチェックを行う。
- [重要] mapとsliceの使用を適切に管理する [全般]
    - `map` や `slice` を関数に渡すと、関数内で要素が変更される可能性があることを理解する（参照型のような振る舞い）。
    - `map` への並行アクセスは致命的なデータ競合を引き起こすため、必ず `sync.Mutex` や `sync.RWMutex` で保護する。`sync.Map` の利用も検討。
    - `append` で `slice` の容量 (`cap`) が超えると、新しい基底配列が割り当てられ、元の配列とは別のメモリ領域になる。
    - `make([]T, length, capacity)` で初期容量を指定することで、頻繁な再割り当てを避けられる場合がある。
- [重要] コンストラクタパターンを活用して一貫した初期化を行う [全般]
    - 構造体の初期化には `NewXxx(...)` 形式のコンストラクタ関数を提供する。ゼロ値が有効でない場合や、初期化にロジックが必要な場合に有用。
    - 複雑な設定やオプションを持つ構造体には、関数オプションパターン (Functional Options Pattern) を検討する。
    ```go
    // 関数オプションパターン例
    type ClientOptions struct { Timeout time.Duration; Retries int }
    type Option func(*ClientOptions)
    func WithTimeout(d time.Duration) Option { /* ... */ }
    func NewClient(opts ...Option) *Client {
        options := ClientOptions{ Timeout: 5*time.Second, Retries: 3 } // デフォルト値
        for _, opt := range opts { opt(&options) } // オプション適用
        // ... client を初期化 ...
    }
    ```
- [重要] ゼロ値を活用する [全般]
    - 構造体のフィールドのゼロ値（`0`, `false`, `""`, `nil` など）が意味のあるデフォルト状態を示すように設計する。
    ```go
    type Config struct { MaxRetries int } // ゼロ値は 0
    func getMaxRetries(cfg Config) int {
        if cfg.MaxRetries == 0 { return 3 } // ゼロ値の場合デフォルトを使用
        return cfg.MaxRetries
    }
    ```
- [重要] 効率的なコードを書く [全般]
    - 小さな値型や構造体では、メソッドレシーバや関数引数でポインタを不必要に使用しない（コピーコストが低い場合）。
    - 大きな構造体では、コピーコストを避けるためにポインタを使用することを検討する。
    ```go
    func ProcessValue(v Value) Result { /* ... */ } // 小さいなら値渡し
    func ProcessLargeStruct(s *LargeStruct) Result { /* ... */ } // 大きいならポインタ渡し
    ```

## 6. パフォーマンスと効率性 [コード]

- [重要] メモリ割り当てを最小限に抑える [全般]
    - ループ内でのスライスやマップの再作成、大きな文字列の連結などを避ける。
    - `make` で `slice` や `map` のサイズ/容量を可能な限り事前に指定する。
    - 一時的な大きなオブジェクト（バッファなど）は `sync.Pool` を使って再利用を検討する。
    - プロファイラ (`pprof`) を使用して、想定外のメモリアロケーションを特定する。
- [重要] 適切なデータ構造を選択する [全般]
    - アクセスパターンに応じて最適なデータ構造を選択する（例: キー検索なら `map`、順序付きアクセスなら `slice`）。
- [重要] プロファイリングを活用してパフォーマンス最適化を行う [アプリ]
    - コードの最適化は、推測ではなく計測に基づいて行う。
    - `go test -bench` でマイクロベンチマークを作成する。
    - `net/http/pprof` で実行中のアプリケーションのCPU、メモリ、ブロック、ゴルーチンなどのプロファイルを取得・分析する。
    - `runtime/trace` で詳細な実行トレースを取得する。
- [重要] I/O効率を最適化する [全般]
    - ファイルやネットワークI/Oには `bufio` パッケージを使用してバッファリングを行う。
    - 大量のデータ転送には `io.Copy` を使用する。
    - システムコール（ファイル操作、ネットワーク操作など）の回数を意識し、可能であればバッチ処理などを検討する。
- [推奨] 効率的な文字列連結を行う [全般]
    - 多数の文字列を連結する場合（特にループ内）は `strings.Builder` を使用するのが最も効率的。
    - 少数の、事前に数がわかっている連結であれば `+` 演算子や `fmt.Sprintf` でも問題ないことが多い。
- [推奨] スケーラブルなアプリケーション設計を行う [アプリ]
    - ステートレスなサービスを目指す（状態は外部ストアに持つ）。
    - 非同期処理、キューイング、キャッシュなどを適切に導入する。
    - タイムアウト、リトライ、サーキットブレーカーなどの回復力パターンを実装する。
    - レートリミットを導入して過負荷を防ぐ。

## 7. ドキュメンテーション [コード]

- [必須] パッケージとエクスポートされた識別子にはGoDocコメントを記述する [全般]
    - `package` 宣言の直前にパッケージコメントを記述する。
    - エクスポートされる型、関数、変数、定数には、その目的、使用法、注意事項などを説明するコメント (`//` で始まる) を識別子の直前に記述する。
    ```go
    // Package cache provides an in-memory caching mechanism.
    package cache

    // Cache stores key-value pairs temporarily. It is safe for concurrent use.
    type Cache struct { /* ... */ }

    // New creates a new Cache with default expiration and cleanup interval.
    func New() *Cache { /* ... */ }

    // Get retrieves a value from the cache. Returns value, true if found, otherwise nil, false.
    func (c *Cache) Get(key string) (interface{}, bool) { /* ... */ }
    ```
- [重要] 例（Examples）を使用して使用方法を示す [ライブラリ]
    - `*_test.go` ファイル内に `ExampleXxx` という形式の関数を作成し、具体的な使用例を示す。
    - `// Output:` コメントを使って期待される出力を記述することで、テストとして実行可能になる (`go test`)。
    ```go
    func ExampleCache_Get() {
        c := cache.New()
        c.Set("message", "hello")
        val, ok := c.Get("message")
        if ok {
            fmt.Println(val)
        }
        // Output: hello
    }
    ```
- [推奨] 複雑なロジックや設計判断には説明を付ける [全般]
    - なぜそのアルゴリズムを選んだのか、なぜ特定の実装方法にしたのか、コードだけでは読み取れない背景や意図をコメントで補足する。
    - `// TODO:` や `// FIXME:` を使って、将来的な改善点や修正が必要な箇所を示す。
- [推奨] パッケージを論理的に整理し、README.mdを提供する [ライブラリ]
    - README.md には、パッケージの概要、インストール方法、簡単な使用例、ドキュメント (pkg.go.dev) へのリンクを含める。

## 8. テスト [コード]

- [必須] テーブル駆動テストを使用して複数のケースをテストする [全般]
    - テストケースを `struct` のスライスとして定義し、`t.Run` を使って各ケースをサブテストとして実行する。
    ```go
    func TestMyFunc(t *testing.T) {
        testCases := []struct{ name string; input string; want string }{ /* ... cases ... */ }
        for _, tc := range testCases {
            t.Run(tc.name, func(t *testing.T) {
                got := MyFunc(tc.input)
                if got != tc.want { t.Errorf("got %q, want %q", got, tc.want) }
            })
        }
    }
    ```
- [重要] モックやスタブを使用して外部依存関係をテストから分離する [全般]
    - 外部システム（DB, API, ファイルシステムなど）への依存はインターフェースを介して行い、テスト時にはインターフェースを満たすモック実装（テストダブル）に差し替える。
    - これにより、テストは外部要因に影響されず、高速かつ安定して実行できる。
- [重要] HTTPハンドラのテスト方法 [アプリ]
    - `net/http/httptest` パッケージの `NewRequest` でテスト用リクエストを作成し、`NewRecorder` でレスポンスを記録する。
    - ハンドラ関数または `http.Handler` を直接呼び出し、レコーダーに記録されたステータスコードやレスポンスボディを検証する。
- [推奨] テストヘルパー関数を作成して重複コードを減らす [全般]
    - テスト内での共通のセットアップ処理やアサーション（比較検証）ロジックは、ヘルパー関数に切り出す。
    - ヘルパー関数内では `t.Helper()` を呼び出すことで、テスト失敗時のレポートが呼び出し元の行番号を指すようになる。
- [推奨] ベンチマークテストを作成してパフォーマンスを測定する [ライブラリ] [アプリ]
    - パフォーマンスが重要な箇所については、`testing` パッケージの `BenchmarkXxx` 関数を作成する (`go test -bench=BenchmarkXxx`)。
    - `b.ReportAllocs()` を使用してメモリアロケーション回数を計測する。
- [推奨] レースコンディション検出 (`go test -race`) を有効にする [全般]
    - 並行処理を含むコードのテストは、常に `-race` フラグを付けて実行し、データ競合がないか確認する。CIパイプラインにも組み込む。

## 9. コードの拡張性と保守性 [設計]

- [必須] モジュールバージョニングと依存関係管理を適切に行う [全般] [プロセス]
    - Go Modules (`go.mod`, `go.sum`) を使用して、プロジェクトの依存関係とそのバージョンを明確に管理する。
    - ライブラリを公開する場合は、セマンティックバージョニング (`vMAJOR.MINOR.PATCH`) に従う。
    - `go mod tidy` を定期的に実行して、`go.mod` と `go.sum` を最新の状態に保つ。
- [重要] APIバージョニングと後方互換性を考慮する [ライブラリ] [アプリ]
    - 公開API（ライブラリの関数や型、HTTPエンドポイントなど）に変更を加える際は、後方互換性を意識する。
    - 互換性のない変更を行う場合は、メジャーバージョンを上げ、利用者が意図的に更新できるようにする（ライブラリならモジュールパス `/vN`、HTTP APIならURLパス `/api/vN` など）。
- [重要] フラグやコンフィグを使用して動作を設定可能にする [アプリ]
    - アプリケーションの挙動（リッスンポート、データベース接続情報、外部APIエンドポイント、機能フラグなど）を、コードの再コンパイルなしに変更できるよう、設定ファイル、環境変数、コマンドラインフラグなどで外部から設定可能にする。
    - `flag`, `os` パッケージ、または `spf13/viper` などのライブラリを活用する。
- [推奨] スマートな拡張ポイントを提供する [ライブラリ]
    - ライブラリの利用者が、ライブラリのコア機能を変更せずに独自の機能を追加したり、挙動をカスタマイズしたりできるように、インターフェース、関数型、プラグイン機構などの拡張ポイントを設けることを検討する（例: HTTPミドルウェア、カスタムストラテジー）。
- [推奨] インターフェースを利用側で定義する [全般]
    - ある機能を利用する側が、その機能に期待する最小限のメソッドセットをインターフェースとして定義する。これにより、実装の詳細への不要な依存を減らせる。
    ```go
    // 利用側 (e.g., service package)
    package service
    type UserNotifier interface { Notify(userID string, message string) error }
    type UserService struct { notifier UserNotifier }
    // ...

    // 実装側 (e.g., email package)
    package email
    type EmailSender struct { /* ... */ }
    func (s *EmailSender) Notify(userID string, message string) error { /* Send email */ }
    ```
- [推奨] 継承より組み合わせ (Composition) を優先する [全般]
    - Goにはクラス継承がない。機能の再利用や拡張は、構造体の埋め込みやフィールドとして他の型を持つことで実現する。
    ```go
    // 良い例: 構造体埋め込み
    type BaseHandler struct { logger *log.Logger }
    func (h *BaseHandler) Log(msg string) { h.logger.Print(msg) }
    type UserHandler struct { BaseHandler; db *sql.DB } // BaseHandlerを埋め込み
    func (h *UserHandler) Handle() { h.Log("Handling user request...") } // 埋め込んだメソッド利用

    // 良い例: フィールドとして持つ
    type TaskProcessor struct { queue JobQueue; worker Worker }
    ```

## 10. ツール、自動化、CI/CD [ツール] [プロセス]

- [必須] Go標準ツールを活用する [全般]
    - `gofmt` / `go fmt`: コードの自動フォーマット。必須。
    - `go vet`: コード中の典型的な誤りや疑わしい構造を検出。定期的な実行を推奨。
    - `go test`: テスト実行。カバレッジ測定 (`-cover`)、レース検出 (`-race`) も活用。
- [重要] 高度な静的解析ツールとリンターを導入する [全般]
    - `staticcheck`: `go vet` より多くのチェックを行う高機能静的解析ツール。導入を強く推奨。
    - `golangci-lint`: 複数のリンター (`staticcheck`, `errcheck`, `unused` など多数) をまとめて実行・管理できるツール。プロジェクトでルールを設定し、CIで実行するのが効果的。
- [重要] 依存関係の脆弱性をチェックする [全般] [セキュリティ]
    - `govulncheck`: Go公式のツールで、プロジェクトが依存するモジュールに含まれる既知の脆弱性を検出する。定期的な実行（特にCI/CD）を推奨。
- [必須] CI/CDパイプラインで自動チェックを実施する [アプリ] / [重要] [ライブラリ] [プロセス]
    - コード変更時に自動的に品質チェックを実行する仕組みを構築する (GitHub Actions, GitLab CI, Jenkins など)。
    - パイプラインに含めるべきステップ例:
        1.  `gofmt -l .` (フォーマットチェック)
        2.  `go vet ./...`
        3.  `staticcheck ./...` または `golangci-lint run`
        4.  `go test -race -cover ./...` (テスト、レース検出、カバレッジ)
        5.  `govulncheck ./...` (脆弱性スキャン)
        6.  `go build ./...` (ビルド確認)

## 11. セキュリティ [セキュリティ] [コード]

- [必須] 入力値検証を徹底する [アプリ] / [重要] [ライブラリ]
    - 外部（ユーザー、他システム、ファイルなど）からの入力は決して信用せず、常に期待される型、フォーマット、長さ、範囲などを厳密に検証・サニタイズする。
    - SQLインジェクション、XSS、パス・トラバーサルなどの典型的な脆弱性を意識して検証処理を実装する。
- [必須] SQLインジェクションを防ぐ [アプリ]
    - SQLクエリを動的に生成する際は、常にプレースホルダ（パラメータ化クエリ）を使用する。`database/sql` や主要なORMはこれに対応している。文字列連結によるクエリ構築は原則禁止。
- [必須] 認証情報を安全に扱う [アプリ] [全般]
    - パスワードは `bcrypt` などの適切なアルゴリズムでハッシュ化して保存する。平文や可逆な暗号化で保存しない。
    - APIキー、パスワード、証明書などのシークレット情報は、コードリポジトリに直接含めず、環境変数、専用の設定ファイル（適切なアクセス権限）、またはシークレット管理ツール（Vaultなど）で管理する。
- [重要] 適切な認証・認可制御を実装する [アプリ]
    - リクエストごとにユーザーを確実に認証し、そのユーザーが要求されたリソースや操作に対する権限を持っているかを確認する。
    - セキュアなセッション管理（推測困難なID、Secure/HttpOnly/SameSite Cookie属性、適切な有効期限など）を行う。
- [重要] 安全な通信を確保する [アプリ] [全般]
    - 外部との通信（クライアントとのHTTPS、外部API呼び出しなど）はTLSを使用して暗号化する。証明書の検証を無効化 (`InsecureSkipVerify`) しない。
- [重要] エラーハンドリングにおける情報漏洩を防ぐ [アプリ]
    - エンドユーザーに返すエラーメッセージには、スタックトレース、内部のファイルパス、データベースエラーの詳細など、攻撃のヒントになりうる情報を含めない。ログには詳細情報を記録する。
- [推奨] HTTPセキュリティヘッダーを設定する [アプリ]
    - `Content-Security-Policy`, `Strict-Transport-Security`, `X-Frame-Options`, `X-Content-Type-Options` などのヘッダーを適切に設定し、ブラウザレベルでのセキュリティを強化する。
- [推奨] 最小権限の原則を適用する [アプリ] [全般]
    - プロセスやユーザーに、そのタスク実行に必要な最小限の権限のみを与える（OS、データベース、ファイルシステムなど）。

## 12. 特別なマーカー

- `// LEGACY`: リファクタリングが必要なレガシーコード箇所を示す。
- `// EXPERIMENTAL`: 実験的な機能やAPIで、将来変更される可能性があることを示す。
- サードパーティコードやコピーされたコードは、ライセンスと出典を明記し、可能であれば専用のディレクトリに隔離する。
